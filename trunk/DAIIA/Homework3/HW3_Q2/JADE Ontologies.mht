From: =?iso-8859-1?B?08kgV2luZG93cyBJbnRlcm5ldCBFeHBsb3JlciA3ILGjtOY=?=
Subject: JADE Ontologies
Date: Tue, 27 Nov 2007 18:59:29 +0100
MIME-Version: 1.0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Ontologies.htm
X-MimeOLE: Produced By Microsoft MimeOLE V6.0.6000.16545

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>JADE Ontologies</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.6000.16546" name=3DGENERATOR></HEAD>
<BODY bgColor=3D#ccccff topMargin=3D20>
<P><FONT size=3D3><STRONG>Building Multi-Agent Systems with=20
JADE</STRONG></FONT></P>
<HR>

<OL type=3DDISC><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/JadePrimer.html"=
>Introduction</A>=20

  <LI><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/primer1.html">In=
stalling=20
  the software</A>=20
  <LI><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/primer2.html">Yo=
ur=20
  first programs</A>=20
  <LI><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/primer3.html">Pa=
rallelism=20
  and <I>Behaviours</I></A>=20
  <LI><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/primer4.html">Ag=
ent=20
  communication</A>=20
  <LI><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/primer5.html">Us=
ing the=20
  Directory Facilities (DF)</A>=20
  <LI><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/primer6.html">Us=
ing=20
  Jade Behaviours</A>=20
  <LI><B><FONT size=3D+1>--&gt; Using ontologies</FONT></B>=20
  <UL>
    <LI><A=20
    =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Ontologies.htm#7=
.1">7.1=20
    The bank example</A>=20
    <LI><A=20
    =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Ontologies.htm#7=
.2">7.2.=20
    Messages with serialized Java objects</A>=20
    <LI><A=20
    =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Ontologies.htm#7=
.3">7.3.=20
    Defining an application-specific ontology </A></LI></UL>
  <LI><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Gui.html">Graphi=
cal=20
  Interfaces</A>=20
  <LI><A =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Mobility.html"=20
  target=3Dapi>Mobility</A> </LI></OL>
<HR>

<H1>7. Using ontologies</H1>
<P align=3Djustify>If agents are to communicate in a way that makes =
sense for=20
them, they must share the same language, vocabulary and protocols. By =
following=20
FIPA standards, Jade already supports a certain degree of commonality; =
this is=20
evident in the use of FIPA communicative acts and the Coder/Decoder =
classes for=20
SLn languages which determine the form of the messages exchanged between =
agents.=20
</P>
<P align=3Djustify>However, you will need to define your own vocabulary =
and=20
semantics for the content of the messsages exchanged between your =
agents. This=20
means defining an ontology. In fact, JADE provides three ways to =
implement=20
communication between agents.=20
<OL type=3D1>
  <LI>The first and most basic way consists of using strings to =
represent the=20
  content of messages. This is the technique that we have used so far in =
all of=20
  our examples. This is convenient when the content of messages is =
atomic data,=20
  but not in the case of abstract concepts, objects or structured data. =
In such=20
  cases, the string needs to be parsed to access its various =
parts.<BR>&nbsp;=20
  <LI>The second way exploits Java technology to transmit =
<I>Serialized</I> Java=20
  objects directly as the content of messages. This is often a =
convenient method=20
  for a local application where all agents are implemented in Java. One=20
  inconvenience is that these messages are not readable by =
humans.<BR>&nbsp;=20
  <LI>The third method involves the definition of the objects to be =
transferred=20
  as extension of predefined classes so that Jade can encode and decode =
messages=20
  in a standard FIPA format. This allows Jade agents to interoperate =
with other=20
  agent systems.
  <P></P></LI></OL>
<P>The three types of message content are reflected by three Depending =
on the=20
types of message content, different methods will be used to <B>set</B> =
and=20
<B>get</B> content. The table below gives the correspondance.=20
<P>
<CENTER>
<TABLE cellSpacing=3D2 cellPadding=3D2 border=3D1>
  <TBODY>
  <TR align=3Dmiddle>
    <TH width=3D70>Content type</TH>
    <TH>Getting content</TH>
    <TH>Setting content</TH></TR>
  <TR align=3Dmiddle>
    <TD align=3Dmiddle>Strings</TD>
    <TD align=3Dmiddle>getContent()</TD>
    <TD align=3Dmiddle>SetContent()</TD></TR>
  <TR align=3Dmiddle>
    <TD align=3Dmiddle>Java Objects</TD>
    <TD align=3Dmiddle>getContentObject()</TD>
    <TD align=3Dmiddle>SetContentObject()</TD></TR>
  <TR align=3Dmiddle>
    <TD align=3Dmiddle>Ontology Objects</TD>
    <TD align=3Dmiddle>extractContent()</TD>
    <TD align=3Dmiddle>fillContent()</TD></TR></TBODY></TABLE></CENTER>
<P>In what follows, we take one application, a Bank example, and =
implement it in=20
two ways. First, we implement communication between agents using =
serialized Java=20
objects. Then, we go the more formal route and convert our objects into =
an=20
ontology with the support provided by JADE.</P>
<H2><A name=3D7.1>7.1 The bank example</A></H2>
<P align=3Djustify>In this example, we create two agents which implement =
the=20
client and server roles for a bank with savings accounts. The <FONT=20
color=3D#000000><STRONG>BankServerAgent</STRONG></FONT> class, acts as a =
server=20
and the <FONT color=3D#000000><STRONG>BankClientAgent</STRONG></FONT> =
class acts=20
as client. The two classes use (<I>implement</I>) a common interface, =
<FONT=20
color=3D#000000><STRONG>BankVocabulary</STRONG></FONT>, that defines the =
constants=20
which represent the terms that constitute the specific language of the =
agents.=20
The <A href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank"=20
target=3DCode>bank directory</A> consists of 3 subdirectories that =
contain the=20
source code for 3 versions of the example. The first version,=20
<I>Bank-1-jObjects</I>, shows how to implement communication between =
agents=20
using <B>Java objects</B>. The second version, <I>Bank-2-Onto</I>, shows =
how to=20
implement the communication between agents using an <B>ontology</B>. And =
the=20
third directory, <I>Bank-3-Gui</I>, adds a graphical user interface that =
will be=20
the subject of the next chapter. </P>
<P align=3Djustify>The conversation between the two agents follows a =
very simple=20
protocol. To create an account or to make an operation, the client agent =
sends a=20
REQUEST message to the server agent. The server agent responds with an =
INFORM=20
after processing the request or with an NOT_UNDERSTOOD if it cannot =
decode the=20
content of the message. To query information about a specific account, =
the=20
client agent sends a QUERY_REF to the server agent which responds with =
an INFORM=20
after processing the query or with a NOT_UNDERSTOOD if it cannot decode =
the=20
content of the message.</P>
<H2><A name=3D7.2>7.2. Messages</A> with serialized Java objects</H2>In =
modeling=20
the interaction between various agents, it is useful to identify the =
pertinent=20
concepts and actions and to define these as classes. Here are the =
classes that=20
are used in the Bank application:=20
<UL>
  <LI><STRONG>Account</STRONG>: concept of a bank savings account=20
  <LI><STRONG>Operation</STRONG>: concept of a bank operation=20
  <LI><STRONG>MakeOperation</STRONG>: action of making an operation such =
as=20
  deposit or withdrawal=20
  <LI><STRONG>OperationList</STRONG>: concept of the list of last =
operations=20
  <LI><STRONG>CreateAccount</STRONG>: action of creating an account=20
  <LI><STRONG>Information</STRONG>: concept of querying information =
about an=20
  account such as the balance and the list <BR>of last operations=20
  <LI><STRONG>Problem</STRONG>: result of an action that fails =
</LI></UL>
<P>These classes can be found in the <A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-1-jObj=
ects/BankServerAgent.java">source=20
file for the server</A>. If objects are to sent as parts of messages, it =
is=20
<U>imperative</U> that they are declared to implement the=20
<STRONG>java.io.Serializable</STRONG> interface, otherwise the =
serialization of=20
the content of the messages before their sending will fail. Below is the =

definition of the <TT>MakeOperation</TT> class. Here we follow the usual =
OO=20
practice of declaring the class attributes <I>private</I> and adding =
public=20
accessor (<B>set/get</B>) methods. This also means that later, when we =
turn=20
these classes into Ontology <I>Content Elements</I>, they can be reused =
with=20
almost no modification.=20
<P>
<DIV align=3Dcenter>
<TABLE cellPadding=3D5 border=3D1>
  <TBODY>
  <TR bgColor=3D#ffffcc>
    <TD><PRE><B>class</B> MakeOperation <B>implements</B> =
java.io.Serializable=20
{
     private String accountId;=20
     private int type;
     private float amount;=20

     <B>public String</B> getAccountId() {
         return accountId;
     }

     <B>public int</B> getType() {
         return type;
     }

     <B>public float</B> getAmount() {
         return amount;
     }

     <B>public void</B> setAccountId(String accountId) {
         this.accountId =3D accountId;
     }

     <B>public void</B> setType(int type) {
         this.type =3D type;
     }

     <B>public void</B> setAmount(float amount) {
         this.amount =3D amount;
     }
} </PRE></TD></TR></TBODY></TABLE></DIV>
<P>Here is an extract of <A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-1-jObj=
ects/BankClientAgent.java"=20
target=3Dcode>BankClientAgent</A> where the client REQUESTs the server =
to carry=20
out a given operation. This is done by creating and sending a=20
<EM>MakeOperation</EM> object.=20
<P>
<DIV align=3Dcenter>
<TABLE cellPadding=3D5 border=3D1>
  <TBODY>
  <TR bgColor=3D#ffffcc>
    <TD><PRE>   MakeOperation mo =3D new MakeOperation();
   mo.setAccountId(acc.getId());
   mo.setType(command);
   mo.setAmount(amount);
  =20
   ACLMessage msg =3D new ACLMessage( ACLMessage.REQUEST );
   msg.addReceiver(server);
   try {
      msg.<B>setContentObject</B>( mo );
   }
   catch (Exception ex) { ex.printStackTrace(); }
   send(msg);
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>
<P>On the other side, the server receives and decode the content of the =
message=20
as implemented in the inner classes <STRONG>ReceiveMessages</STRONG> and =

<STRONG>HandleOperation </STRONG>of the <A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-1-jObj=
ects/BankServerAgent.java"=20
target=3Dcode>BankServerAgent</A> class:</P>
<P>
<DIV align=3Dcenter>
<TABLE cellPadding=3D5 border=3D1>
  <TBODY>
  <TR bgColor=3D#ffffcc>
    <TD><PRE> class ReceiveMessages extends CyclicBehaviour=20
{=20
      public ReceiveMessages(Agent a) {=20

           super(a);=20
      }

      public void action()=20
      {=20
         ACLMessage msg =3D receive();
         if (msg =3D=3D null) { block(); return; }
        =20
         try {
           Object content =3D msg.getContentObject();

           switch (msg.getPerformative()) {
          =20
           case (ACLMessage.REQUEST):
               if (action instanceof CreateAccount)
                   addBehaviour(new HandleCreateAccount(myAgent, msg));
               else if (content instanceof MakeOperation)
                   addBehaviour(new HandleOperation(myAgent, msg));
               ...
      }
}=20

class HandleOperation extends OneShotBehaviour=20
{=20
      ACLMessage request;

      public HandleOperation(Agent a, ACLMessage request) {=20

           super(a);
           this.request =3D request=20
      }

      public void action() {=20

         try {
           Operation op =3D (Operation)
           request.getContentObject();
           ACLMessage reply =3D request.createReply();
           // Process the operation
           Object result =3D processOperation(op);
           ...
         }
         catch (Exception ex) { ex.printStackTrace(); }=20
      }
}  </PRE></TD></TR></TBODY></TABLE></DIV>
<P>
<H2><A name=3D7.3>7.3.</A> Defining an application-specific ontology =
</H2>
<P>An application-specific ontology describes the elements that can be =
used as=20
content of agent messages.An ontology is composed of two parts, a =
vocabulary=20
that describe the terminology of concepts used by agents in their space =
of=20
communication, and the nomenclature of the relationships between these =
concepts,=20
and that describe their semantic and structure. You implement an =
ontology for=20
your application by extending the class <STRONG>Ontology</STRONG> =
predefined in=20
JADE and adding a set of element schemas describing the structure of =
concepts,=20
actions, and predicates that are allowed to compose the content of your=20
messages. You may also extend directly the basic ontology classes=20
<STRONG>BasicOntology</STRONG> or <STRONG>ACLOntology </STRONG>according =
to your=20
need. But if you do so, you also indirectly extend the ontology class =
since=20
these two classes are themselves subclasses of the <EM>Ontology</EM> =
class.</P>
<P>In the version 2 of the bank example, we defined the <A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/BankOntology.java"=20
target=3Dcode>BankOntology</A> class that our two agents use to =
communicate in=20
place of the java objects that we discussed previously. We do not "throw =
away"=20
our java objects that remain in fact valid, but instead of using them =
directly=20
in the content of messages, we just wrapp them into specifics terms and =
concepts=20
defined within the <FONT color=3D#000000><EM>BankOntology</EM></FONT> =
class. To do=20
that, we just modified slightly our java classes by making them =
implement the=20
appropriate interfaces provided by JADE. In fact, when defining an =
ontology you=20
will generally deal with the three interfaces<STRONG> Concept</STRONG>,=20
<STRONG>AgentAction</STRONG> and <STRONG>Predicate</STRONG>. The =
corresponding=20
classes to be used in your ontology class are respectively the=20
<STRONG>ConceptSchema</STRONG>, <STRONG>AgentActionSchema</STRONG> and=20
<STRONG>PredicateSchema</STRONG>.</P>
<P>Examining the hierarchy of these classes, we see that the=20
<EM>AgentActionSchema</EM> class inherits from the =
<EM>ConceptSchema</EM> class=20
which in turn is a subclass of the <EM>TermSchema</EM> class. While the=20
<EM>PredicateSchema</EM> class inherits from the =
<EM>ContentElementSchema</EM>=20
class. But at the base, these interfaces have a common superclass which =
is the=20
<EM>ObjectSchema</EM> class.</P><PRE>      java.lang.Object
      |
      +--jade.content.schema.ObjectSchema
      |
      +--jade.content.schema.ObjectSchemaImpl
      |
      +--jade.content.schema.TermSchema
      |
      +--jade.content.schema.ConceptSchema
      |
      +--jade.content.schema.AgentActionSchema


      java.lang.Object
      |
      +--jade.content.schema.ObjectSchema
      |
      +--jade.content.schema.ObjectSchemaImpl
      |
      +--jade.content.schema.ContentElementSchema
      |
      +--jade.content.schema.PredicateSchema

</PRE>
<P>An important point to know is when to use one or another of these =
ontology=20
objects. To briefly explain that, let's examine these three =
examples:</P>
<DIV>
<OL>
  <LI>Agent A requests agent B to perform a specific task. According to =
FIPA,=20
  the content of the message that A sends to B must be an "action", =
i.e., a=20
  tuple which slots are the <EM>identifier</EM> of agent that is =
requested to=20
  perform the action (here agent B) and a <EM>descriptor</EM> =
respresenting the=20
  task to be performed (here the requested task). In JADE, the task will =
be=20
  defined by a java object implementing the <EM>AgentAction</EM> =
interface and=20
  the action will be an instance of the class <STRONG>Action</STRONG> to =
which=20
  you pass in arguments the AID of agent B and the object describing the =
task to=20
  be performed. <BR>&nbsp;=20
  <LI>Agent A asks agent B if a given proposition is true. According to =
FIPA,=20
  the content of the message must be the object representing the =
proposition to=20
  check. In JADE a proposition can be defined by a java object =
implementing the=20
  interface <EM>Predicate</EM>. <BR>&nbsp;=20
  <LI>Now let's take an example closer to our bank example: suppose the =
client=20
  agent requests the server agent to perform an action consisting of =
making a=20
  deposit on a given account. To do this, we defined the class=20
  <EM>MakeOperation</EM> describing the action to be performed. Since it =
is an=20
  action, we make the <EM>MakeOperation</EM> class implement the=20
  <EM>AgentAction</EM> interface. On the server side, once it has =
processed the=20
  information, it replies by sending back together with the requested =
action=20
  wrapped in a <STRONG>Result</STRONG> object, an<EM> Account</EM> =
object=20
  representing the result of processing the operation or a=20
  <STRONG>Problem</STRONG> object if the action failed. As the =
<EM>Account</EM>=20
  and <EM>Problem</EM> object are not agent actions neither =
propositions, we=20
  simply defined them as concepts by implementing the interface=20
  <EM>Concept</EM>. </LI></OL>
<P>Besides these three interfaces that allow you to define the abstracts =
objects=20
of your application ontology, JADE also provides support for defining =
atomic=20
elements that constitute generally the slots of the abstract concepts, =
such as=20
<EM>String</EM>, <EM>Integer</EM>, <EM>Float</EM> and so on. The support =
for=20
these atomic types of objects is provided through the class=20
<STRONG>PrimitiveSchema</STRONG> and handled by the =
<EM>BasicOntology</EM>=20
class.</P></DIV>
<P>Applying these principles, the java objects previously defined in the =
version=20
1 of the bank example are modified as follows (you can access the files =
under=20
the directory <STRONG>Bank-2-Onto</STRONG>):</P>
<DIV>
<UL>
  <LI>the <A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/Account.java"=20
  target=3Dcode>Account</A> class now implements the <EM>Concept</EM> =
interface=20
  <LI>the <A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/Operation.java"=20
  target=3Dcode>Operation</A><STRONG> </STRONG>class implements the=20
  <EM>Concept</EM> interface=20
  <LI>the <A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/MakeOperation.java"=20
  target=3Dcode>MakeOperation</A> class implements the =
<EM>AgentAction</EM>=20
  interface=20
  <LI>the<STRONG> </STRONG><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/CreateAccount.java"=20
  target=3Dcode>CreateAccount</A> class implements the =
<EM>AgentAction</EM>=20
  interface=20
  <LI>the<STRONG> </STRONG><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/Information.java"=20
  target=3Dcode>Information</A> class implements the =
<EM>AgentAction</EM>=20
  interface=20
  <LI>the<STRONG><STRONG> </STRONG></STRONG><A=20
  =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/Problem.java"=20
  target=3Dcode>Problem</A> class implements the <EM>Concept</EM> =
interface=20
</LI></UL></DIV>
<P>Comparativeley with the version 1, only one class disappeared. This =
is the=20
<EM>OperationList</EM> class which is of no use now since the =
<EM>Result</EM>=20
class (which is provided by JADE) that we use to hold the result of =
actions that=20
are performed by the server agent already contains a <EM>List</EM> =
object as=20
attribute.</P>
<P>Now let's see step by step how to put together all these pieces of =
puzzle to=20
define an application-specific ontology by examining the example of =
making an=20
operation.</P>
<P><STRONG>Step 1:</STRONG> you define the vocabulary of your agents=20
communication space. In the <A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/BankVocabulary.java"=20
target=3Dcode>BankVocabulary</A> interface, we have the following lines =
of code=20
that define the terminology involved in the concept of making an =
operation:</P>
<P>
<DIV align=3Dcenter>
<TABLE cellPadding=3D5 border=3D1>
  <TBODY>
  <TR bgColor=3D#ffeeee>
    <TD><PRE>     <B>public interface</B> BankVocabulary=20
    {
        ...

        public static final String MAKE_OPERATION =3D "MakeOperation";
        public static final String MAKE_OPERATION_TYPE =3D "type";
        public static final String MAKE_OPERATION_AMOUNT =3D "amount";
        public static final String MAKE_OPERATION_ACCOUNTID =3D =
"accountId";
        ...
    }
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>
<P><STRONG>Step 2:</STRONG> you define the java class that specifies the =

structure and semantic of the object <EM>MakeOperation</EM>. This is =
almost the=20
same definition as we used in the previous example except that it =
implements=20
<I>AgentAction</I> and not <I>java.io.Serializable</I> </P>
<P>
<DIV align=3Dcenter>
<TABLE cellPadding=3D5 border=3D1>
  <TBODY>
  <TR bgColor=3D#ffffcc>
    <TD><PRE><B>class</B> MakeOperation <B>implements</B> AgentAction=20
{
     private String accountId;=20
     private int type;
     private float amount;=20

     <B>public String</B> getAccountId() {
         return accountId;
     }

     <B>public int</B> getType() {
         return type;
     }

     <B>public float</B> getAmount() {
         return amount;
     }

     <B>public void</B> setAccountId(String accountId) {
         this.accountId =3D accountId;
     }

     <B>public void</B> setType(int type) {
         this.type =3D type;
     }

     <B>public void</B> setAmount(float amount) {
         this.amount =3D amount;
     }
} </PRE></TD></TR></TBODY></TABLE></DIV>
<P>
<P>A java class defining an ontology object must necessarily include the =

<STRONG>set</STRONG> and <STRONG>get</STRONG> methods that allow to =
access the=20
attributes of the class that must be declared private. Take care when =
choosing=20
the attributes names of your object and their corresponding <EM>get</EM> =
and=20
<EM>set</EM> methods. In fact, you can not choose any name you like at =
this step=20
because they must imperatively match (case insensitive) the names that =
you gave=20
to these attributes when defining the vocabulary. for example in the =
vocabulary,=20
we decided that the name for the element MAKE_OPERATION_TYPE is "type". =
So in=20
the java class, the name of the attribute must be <EM>type</EM> and the=20
corresponding <EM>get</EM> and <EM>set</EM> methods must be =
<EM>getType()</EM>=20
and <EM>setType()</EM>. This is an important point to be aware about =
because=20
during the operation of filling the content of the message, the content =
manager=20
first reads the attribute <EM>type</EM> that it associates with the =
class=20
<EM>MakeOperation</EM>. It then searches in the ontology under the=20
<EM>MakeOperation</EM> schema, for the element identified in the =
vocabulary by=20
the name "type". If it cannot find such an element it throws an =
exception.</P>
<P><STRONG>Step 3:</STRONG> you define the schema of the object. In the =
<A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/ontologies/BankOntology.java"=20
target=3Dcode>BankOntology</A> class we find these lines of code that =
specifiy the=20
schema of the concept <EM>MakeOperation</EM>:</P>
<DIV>
<BLOCKQUOTE></BLOCKQUOTE></DIV>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2><STRONG>public =
class=20
    BankOntology extends Ontology implements BankVocabulary=20
{</STRONG></FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>// =
----------&gt; The name=20
    identifying this ontology<BR>public static final String =
ONTOLOGY_NAME =3D=20
    "Bank-Ontology";</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>// =
----------&gt; The=20
    singleton instance of this ontology<BR>private static Ontology =
instance =3D=20
    new BankOntology();</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>// =
----------&gt; Method=20
    to access the singleton ontology object<BR>public static Ontology=20
    getInstance() { return instance; }</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>// Private=20
    constructor<BR>private BankOntology() {</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" =
size=3D2>super(ONTOLOGY_NAME,=20
    BasicOntology.getInstance());</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>try =
{</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>// ------- Add =

    Concepts</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>...</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>// ------- Add =

    AgentActions</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>...</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>//=20
    MakeOperation<STRONG><BR>add(as =3D new =
AgentActionSchema(MAKE_OPERATION),=20
    MakeOperation.class);<BR>as.add(MAKE_OPERATION_TYPE, =
(PrimitiveSchema)=20
    getSchema(BasicOntology.INTEGER),=20
    ObjectSchema.MANDATORY);<BR>as.add(MAKE_OPERATION_AMOUNT, =
(PrimitiveSchema)=20
    getSchema(BasicOntology.FLOAT),=20
    ObjectSchema.MANDATORY);<BR>as.add(MAKE_OPERATION_ACCOUNTID,=20
    (PrimitiveSchema) getSchema(BasicOntology.STRING),=20
    ObjectSchema.MANDATORY);</STRONG></FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" =
size=3D2>...<BR>}<BR>catch=20
    (OntologyException oe) {<BR>oe.printStackTrace();<BR>}<BR>}<BR>}//=20
    BankOntology</FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P>Note that the constructor of your ontology class must be defined with =
private=20
access and include the static public method <EM>getInstance()</EM> that =
your=20
agent program calls to get a reference to the singleton instance of your =

ontology class.</P>
<P>In the class <EM>AgentActionSchema</EM>, you have a set of =
<EM>add(...)</EM>=20
methods, some of which are inherited from the <EM>ConceptSchema</EM> =
class that=20
it extends. These methods allow you to add to the schema of the object =
that you=20
are defining, the elements that will be used by the content manager as =
slots=20
when filling the content of messages. In our example, we used the<EM> =
add()</EM>=20
method that takes three arguments, the name of the slot to be added, the =
schema=20
of this slot and the <STRONG>optionality</STRONG>. The optionlaity can =
take two=20
values: MANDATORY indicating that the slot cannot have a null value, or =
OPTIONAL=20
indicating that it can have a null value. The consequence is that if you =
specify=20
MANDATORY, then this element must be imperatively provided when setting =
the=20
values of corresponding attributes in the java class. On the other hand =
if you=20
specify OPTIONAL, you are allowed to not provide a value for this slot. =
</P>
<P><STRONG>Step 4:</STRONG> you are now ready to use the ontology for =
the=20
content of your agents messages. To set the content of a message using =
an=20
ontology, you must first register with the agent's content manager, the =
ontology=20
and the language that will be used for assembling and parsing(or coding =
and=20
decoding) the content of messages. In our example we use the codec =
language=20
which is implemented in JADE through the class <STRONG>SLCodec</STRONG> =
and the=20
ontology is naturally our <EM>BankOntology</EM>: In the <A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/BankClientAgent.java"=20
target=3Dcode>BankClientAgent</A> class in the directory =
<EM>Bank-2-Onto</EM>, you=20
find these lines of code that illustrate how to register the language =
and=20
ontology:</P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>public class=20
    BankClientAgent extends Agent implements BankVocabulary {</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" =
size=3D2>...<BR><STRONG>private=20
    Codec codec =3D new SLCodec();<BR>private Ontology ontology =3D=20
    BankOntology.getInstance();</STRONG></FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>protected void =
setup()=20
    {</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>// Register =
language and=20
    =
ontology<BR><STRONG>getContentManager().registerLanguage(codec);<BR>getCo=
ntentManager().registerOntology(ontology);</STRONG></FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" =
size=3D2>...<BR>}</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" =
size=3D2>...<BR><BR>}//class=20
    BankClientAgent</FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P>To use the ontoloy when composing your message, you first set the =
attributes=20
of your java object. Then you specify within the message instance, the =
language=20
and ontology that it complies to. you then obtain a reference to the=20
<STRONG>ContentManager</STRONG> object by calling the method=20
<STRONG>getContentManager()</STRONG> of the <EM>Agent</EM> class. =
Finally you=20
call the <STRONG>fillContent(...)</STRONG> method of the =
<EM>ContentManager</EM>=20
object to which you pass in arguments the message and the content that =
it will=20
be filled with. This is done through the following lines of code:</P>
<BLOCKQUOTE>
  <BLOCKQUOTE>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>public class=20
    BankClientAgent extends Agent implements BankVocabulary {</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>...</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>void =
requestOperation()=20
    {</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono"=20
    size=3D2>....<BR><STRONG>MakeOperation mo =3D new=20
    =
MakeOperation();<BR>mo.setType(command);<BR>mo.setAmount(amount);<BR>mo.s=
etAccountId(acc.getId());</STRONG><BR>sendMessage(ACLMessage.REQUEST,=20
    mo);<BR>}</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>...</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" size=3D2>void =
sendMessage(int=20
    performative, AgentAction action) {</FONT></P>
    <P><FONT face=3D"Courier New, Courier, mono" =
size=3D2>...<BR>ACLMessage msg =3D=20
    new=20
    =
ACLMessage(performative);<BR><STRONG>msg.setLanguage(codec.getName());<BR=
>msg.setOntology(ontology.getName());</STRONG><BR>try=20
    {<BR><STRONG>getContentManager().fillContent(msg, new Action(server, =

    =
action));</STRONG><BR>msg.addReceiver(server);<BR>send(msg);<BR>...<BR>}<=
BR>catch=20
    (Exception ex) { ex.printStackTrace(); }<BR>}<BR>}//End=20
    BankClientAgent</FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P>At the server side, you follow the same steps to receive and extract =
the=20
content of the message. The server agent must also register its content =
manager=20
with the same language and ontology. Then, obtaining a reference to the =
content=20
manager object it calls its method <STRONG>extractContent(...)</STRONG> =
to which=20
it passes in argument the message to be extracted. It then casts the =
extracted=20
content with the java class that it was expecting. Once it has the java =
object,=20
it can finally retrieve the content of the slots by calling the =
<EM>get</EM>=20
methods provided in the java class of the object. This is illustrated =
through=20
the following lines of code in the <A=20
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Bank/Bank-2-Onto=
/BankServerAgent.java"=20
target=3Dcode>BankServerAgent</A> class:</P>
<P>
<DIV align=3Dcenter>
<TABLE cellPadding=3D5 border=3D1>
  <TBODY>
  <TR bgColor=3D#ffffcc>
    <TD><PRE> public class BankServerAgent extends Agent implements =
BankVocabulary=20
{
   ...
   private Codec codec =3D new SLCodec();
   private Ontology ontology =3D BankOntology.getInstance();
   ...

   <B>protected void</B> setup() {

      // Register language and ontology
      getContentManager().registerLanguage(codec);
      getContentManager().registerOntology(ontology);
      ...
   }

   ...

   <B>class</B> ReceiveMessages <B>extends</B> CyclicBehaviour
   {
      public ReceiveMessages(Agent a)=20
      {
         super(a);
      }
  =20
      <B>public void</B> action()=20
      {
         ACLMessage msg =3D receive();
         if (msg =3D=3D null) { block(); return; }
           =20
       <B>try</B> {
         ContentElement content =3D =
getContentManager().extractContent(msg);
         Concept action =3D ((Action)content).getAction();
  =20
         switch (msg.getPerformative())=20
         {    =20
         case (ACLMessage.REQUEST):
           ...      =20
            if (action instanceof CreateAccount)
                addBehaviour(new HandleCreateAccount(myAgent, msg));
            else if (action instanceof MakeOperation)
                addBehaviour(new HandleOperation(myAgent, msg));
            ...
            break;
  =20
            ...
        }
        <B>catch</B>(Exception ex) { ex.printStackTrace(); }
      }
   }// End ReceiveMessages

   ...

   <B>class</B> HandleOperation <B>extends</B> OneShotBehaviour=20
   {
      private ACLMessage request;
  =20
      HandleOperation(Agent a, ACLMessage request)=20
      {
         super(a);
         this.request =3D request;
      }
  =20
      <B>public void</B> action()=20
      {
        <B>try</B> {
          ContentElement content =3D =
getContentManager().extractContent(request);
          MakeOperation mo =3D =
(MakeOperation)((Action)content).getAction();
          //Process the operation
          Object obj =3D processOperation(mo);
          //Send the reply
          ...
        }
        <B>catch</B>(Exception ex) { ex.printStackTrace(); }
      }
     =20
   }// End HandleOperation
   ...

  }// End BankServerAgent
</PRE></TD></TR></TBODY></TABLE></DIV>
<P>
<HR>

<BLOCKQUOTE>
  <DL>
    <DT><A=20
    =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/JadePrimer.html"=
>Top</A>=20

    <DD><A=20
    =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/primer6.html">Pr=
evious</A>=20

    <DD><A=20
    =
href=3D"http://www.iro.umontreal.ca/~vaucher/Agents/Jade/Gui.html">Next</=
A>=20
    </DD></DL></BLOCKQUOTE></BODY></HTML>
